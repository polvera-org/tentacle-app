plan:
  title: ten-31-add-notification-system
  goal: "Add a V1 notification system that supports global and user-targeted notifications via Supabase RLS, fetches updates on app load with daily polling, and shows a dismissible update popup for outdated app versions."
  steps[6]:
    - title: add-supabase-notifications-migration-with-rls
      goal: "Create the notifications database schema and RLS policies that let unauthenticated users read global notifications and authenticated users read global plus own notifications."
      context: "Supabase SQL migrations live in `supabase/migrations` and currently follow numbered files with comment sections and explicit grants, as seen in `supabase/migrations/001_initial_schema.sql` and `supabase/migrations/002_documents.sql`. Existing migrations use `CREATE TABLE IF NOT EXISTS`, `ALTER TABLE ... ENABLE ROW LEVEL SECURITY`, named policies, and explicit `GRANT` statements. There is currently no notifications table. The required notification payload for V1 is type `UPDATE` with `notification_data` containing the target version id."
      instructions: "Create `supabase/migrations/003_notifications.sql` only. In this migration, define a notification type enum with currently one value `UPDATE`, create `public.notifications` with columns `id UUID DEFAULT gen_random_uuid() PRIMARY KEY`, `user_id UUID NULL REFERENCES auth.users(id) ON DELETE CASCADE`, `notification_type public.notification_type NOT NULL`, `notification_data JSONB NOT NULL DEFAULT '{}'::jsonb`, and `created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()`. Add indexes for `user_id`, `notification_type`, and `created_at DESC`. Enable RLS. Add a SELECT policy that allows rows where `user_id IS NULL OR auth.uid() = user_id` so unauthenticated clients can read global rows and authenticated users can read both global and personal rows. Add service-role management policies for insert/update/delete. Grant `SELECT` on `public.notifications` to `anon` and `authenticated`, and grant full access to `service_role`. Add concise comments documenting that `notification_data` for `UPDATE` must include `version_id`. Do not edit `001_initial_schema.sql` or `002_documents.sql`."
      verification: "Run `rg -n 'CREATE TABLE IF NOT EXISTS public.notifications|ENABLE ROW LEVEL SECURITY|user_id IS NULL OR auth.uid\\(\\) = user_id|GRANT SELECT ON public.notifications TO anon, authenticated|notification_data' supabase/migrations/003_notifications.sql` and verify all expected clauses are present."
    - title: add-notification-types-and-version-comparison-utilities
      goal: "Define typed notification data contracts and version comparison helpers used by the notification fetch logic and UI."
      context: "Frontend shared interfaces are organized under `frontend/types` and use snake_case API field naming, for example `frontend/types/documents.ts`. There is no notifications type file yet. Version values currently exist in package metadata (`frontend/package.json` version `0.1.0`) and Tauri app metadata (`frontend/src-tauri/tauri.conf.json` version `0.1.0`), but there is no utility to read local runtime version or compare semantic version strings."
      instructions: "Create `frontend/types/notifications.ts` and `frontend/lib/notifications/version.ts`. In `frontend/types/notifications.ts`, add: `NotificationType = 'UPDATE'`, a base row shape for Supabase notifications (`id`, `user_id`, `notification_type`, `notification_data`, `created_at`), and an `UpdateNotificationData` shape containing at minimum `version_id: string` with optional display fields like `title`, `message`, and `release_url`. In `frontend/lib/notifications/version.ts`, export functions to parse and compare dotted numeric version ids (for example `0.1.9 < 0.2.0`) and export `getLocalAppVersion()` that prefers Tauri runtime version via dynamic import when available and falls back to `process.env.NEXT_PUBLIC_APP_VERSION ?? '0.0.0'`. Keep utilities pure and framework-agnostic. Do not modify existing document-related type files in this step."
      verification: "Run `cd frontend && npx tsc --noEmit` and verify the new modules compile with no type errors."
    - title: implement-supabase-notification-fetch-and-latest-update-selection
      goal: "Add a notification data-access module that fetches visible notifications and returns only the newest applicable UPDATE notification for the current app version."
      context: "Supabase client creation pattern is `createClient()` in `frontend/lib/auth/supabase-client.ts`. Auth state comes from `useAuth()` in `frontend/lib/auth/auth-context.tsx` and provides `user` and `isLoading`. Step output available: `frontend/types/notifications.ts` defines notification row and update payload shapes, and `frontend/lib/notifications/version.ts` exports version parsing/comparison and local version helpers. There are currently no Next API routes in this repository, so Supabase reads should happen in client-side utilities."
      instructions: "Create `frontend/lib/notifications/api.ts`. Export a function `fetchLatestUpdateNotification(params: { userId: string | null; localVersion: string }): Promise<UpdateNotificationData & { id: string; created_at: string } | null>`. Query `notifications` via Supabase with selected columns `id,user_id,notification_type,notification_data,created_at`, filter to `notification_type = 'UPDATE'`, and apply visibility filters: unauthenticated users fetch only `user_id IS NULL`; authenticated users fetch rows matching `user_id IS NULL` OR their own user id. Parse defensively so malformed rows are ignored. From valid UPDATE rows, keep only entries where `notification_data.version_id` is greater than `localVersion`, then choose a single notification representing the highest version; if versions tie, prefer the newest `created_at`. Return `null` when no applicable update exists. Do not add server routes and do not modify auth context in this step."
      verification: "Run `cd frontend && npx tsc --noEmit && npm run lint` and verify `frontend/lib/notifications/api.ts` exports `fetchLatestUpdateNotification` with the required filter logic."
    - title: build-app-notifications-provider-with-load-and-daily-polling
      goal: "Create a provider that fetches update notifications on app startup, polls once per day, and applies one-day local dismissal rules."
      context: "Global providers are composed in `frontend/app/layout.tsx` inside `AuthProvider` and `EmbeddingModelStartupGate`. Existing provider pattern is `frontend/components/providers/embedding-model-startup-gate.tsx` using client-side effects and cleanup. Step output available: `frontend/lib/notifications/api.ts` exports `fetchLatestUpdateNotification`, and `frontend/lib/notifications/version.ts` exports `getLocalAppVersion`. Dismissal must persist in `localStorage` for one day."
      instructions: "Create `frontend/components/providers/app-notifications-provider.tsx` as a client component. It should use `useAuth()` to access `user` and wait until auth loading completes before fetching. On initial mount, fetch update notifications immediately, then start a polling interval of `24 * 60 * 60 * 1000` milliseconds to refresh daily. Keep interval cleanup on unmount. Maintain internal state for the active update notification and expose a dismiss handler. Use localStorage keys scoped by version (for example `tentacle.notifications.dismissed.update.<version_id>`) to suppress a dismissed notification for 24 hours, then allow it to reappear if still applicable. Keep this provider focused on orchestration state only; UI rendering belongs to a dedicated component. Do not modify document-grid logic or settings modal in this step."
      verification: "Run `rg -n '24 \\* 60 \\* 60 \\* 1000|tentacle.notifications.dismissed.update|fetchLatestUpdateNotification|getLocalAppVersion' frontend/components/providers/app-notifications-provider.tsx` and confirm load, polling, and dismissal logic are present."
    - title: add-update-popup-ui-and-wire-provider-into-root-layout
      goal: "Render a non-intrusive dismissible update popup and mount notification orchestration so it runs on app load for both authenticated and unauthenticated users."
      context: "Non-intrusive fixed-position feedback components currently include `frontend/components/ui/error-toast.tsx` and toast provider wiring in `frontend/components/ui/app-toaster.tsx`. Root composition is in `frontend/app/layout.tsx`, currently wrapping children in `AuthProvider` and `EmbeddingModelStartupGate`. Step output available: `frontend/components/providers/app-notifications-provider.tsx` owns notification state and dismissal handlers."
      instructions: "Create `frontend/components/notifications/update-notification-popup.tsx` with props for the selected update notification and `onDismiss`. Implement a compact fixed popup with concise copy indicating an update is available, show the target version id, and include a dismiss button with accessible labeling. Optionally render an update link when `release_url` exists in notification data. Keep touch-friendly controls and avoid full-screen modal behavior. Then modify `frontend/app/layout.tsx` to wrap app children with `AppNotificationsProvider` so notification fetch runs from app startup context. Ensure existing `AppToaster` and embedding startup gate remain functional. Do not alter auth logic or document pages in this step."
      verification: "Run `cd frontend && npx tsc --noEmit && npm run lint` and verify `frontend/app/layout.tsx` includes `AppNotificationsProvider` and the popup component is exported from `frontend/components/notifications/update-notification-popup.tsx`."
    - title: execute-end-to-end-verification-for-notification-v1
      goal: "Validate schema, typing, and user behavior for global and targeted update notifications including daily polling and one-day dismissal persistence."
      context: "Expected changed files are `supabase/migrations/003_notifications.sql`, `frontend/types/notifications.ts`, `frontend/lib/notifications/version.ts`, `frontend/lib/notifications/api.ts`, `frontend/components/providers/app-notifications-provider.tsx`, `frontend/components/notifications/update-notification-popup.tsx`, and `frontend/app/layout.tsx`. Notification fetch path should work for both authenticated and unauthenticated sessions because of RLS plus client query filters."
      instructions: "Run quality gates and a focused manual check. Commands: `cd frontend && npx tsc --noEmit && npm run lint && npm run build`. Manual behavior check: insert one global UPDATE notification and one user-targeted UPDATE notification in Supabase; launch app unauthenticated and confirm only global update is eligible; authenticate as target user and confirm targeted update can be shown; dismiss the popup and confirm it stays hidden for 24 hours via localStorage; clear the dismissal key or advance time and confirm popup can appear again; verify only the latest higher version notification is shown when multiple UPDATE rows exist above local version. Do not expand scope beyond notification V1."
      verification: "All listed frontend checks pass and manual scenario confirms visibility rules, latest-version selection, and one-day dismissal persistence."
  acceptance_criteria[8]:
    - title: notifications-table-and-enum-exist
      requirement: "`supabase/migrations/003_notifications.sql` creates `public.notification_type` with `UPDATE` and creates `public.notifications` with `user_id`, `notification_type`, `notification_data`, and `created_at`; verify by reading the migration file."
    - title: rls-allows-global-and-own-notification-reads
      requirement: "RLS on `public.notifications` includes a SELECT policy using `user_id IS NULL OR auth.uid() = user_id`, and grants include `SELECT` for `anon` and `authenticated`; verify with `rg -n 'user_id IS NULL OR auth.uid\\(\\) = user_id|GRANT SELECT ON public.notifications TO anon, authenticated' supabase/migrations/003_notifications.sql`."
    - title: notification-types-and-version-utils-are-typed
      requirement: "`frontend/types/notifications.ts` defines notification/update shapes and `frontend/lib/notifications/version.ts` exports version comparison plus local-version resolver; verify with `cd frontend && npx tsc --noEmit`."
    - title: fetch-logic-supports-unauth-and-auth-scopes
      requirement: "`frontend/lib/notifications/api.ts` filters UPDATE notifications to global rows for unauthenticated users and global-or-own rows for authenticated users; verify by code inspection and lint/type checks."
    - title: only-latest-applicable-update-is-selected
      requirement: "When multiple UPDATE notifications have versions above local version, selection logic returns exactly one notification for the highest version (tie-broken by newest `created_at`); verify by unit-style reasoning in code and manual data checks."
    - title: startup-fetch-and-daily-polling-are-implemented
      requirement: "`frontend/components/providers/app-notifications-provider.tsx` performs initial fetch on mount and schedules refresh every 24 hours; verify with `rg -n 'setInterval|24 \\* 60 \\* 60 \\* 1000' frontend/components/providers/app-notifications-provider.tsx`."
    - title: popup-dismissal-is-persisted-for-one-day
      requirement: "Dismissing the update popup stores a version-scoped localStorage timestamp and suppresses that version for 24 hours; verify by code inspection and manual browser storage checks."
    - title: frontend-quality-gates-pass
      requirement: "`cd frontend && npx tsc --noEmit && npm run lint && npm run build` completes without errors after implementation."
