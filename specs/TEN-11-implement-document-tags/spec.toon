plan:
  title: ten-11-document-tags-and-local-sqlite-cache
  goal: "Add editable document tags stored in markdown frontmatter and introduce cached document listing from a hidden sqlite database that loads instantly and reindexes in the background with visible sync status."
  steps[6]:
    - title: extend-document-model-and-frontmatter-for-tags
      goal: "Add first-class tags to the frontend document types and markdown serialization/parsing so tags round-trip through local markdown files."
      context: "Frontend document contracts are in `frontend/types/documents.ts`: `Document`, `DocumentListItem`, `CreateDocumentPayload`, and `UpdateDocumentPayload`. Local markdown storage logic is in `frontend/lib/documents/api.ts` with `MarkdownFrontmatter`, `parseFrontmatter`, `serializeFrontmatter`, `readStoredDocument`, `writeStoredDocument`, `createDocument`, `fetchDocument`, `fetchDocuments`, and `updateDocument`. Existing frontmatter keys are `id`, `created_at`, `updated_at`, and `banner_image_url`. Existing naming conventions: snake_case frontmatter keys, ISO timestamp strings, default title `Untitled`, and local documents mapped with `user_id: 'local'`. Backward compatibility requirement: existing markdown files without a tags field must still load successfully as empty tags arrays."
      instructions: "Modify only `frontend/types/documents.ts` and `frontend/lib/documents/api.ts` in this step. In `frontend/types/documents.ts`, add `tags: string[]` to `Document` and `DocumentListItem`, and add optional `tags?: string[]` to `CreateDocumentPayload` and `UpdateDocumentPayload`. In `frontend/lib/documents/api.ts`, extend `MarkdownFrontmatter` to include `tags: string[]`; add helpers to normalize, deduplicate, and sanitize tags; update `parseFrontmatter` to read a `tags` line formatted as an inline array (for example `tags: [\"product\", \"idea\"]`) and default to `[]` if missing/invalid; update `serializeFrontmatter` to always write a `tags` field; ensure `readStoredDocument` sets `metadata.tags` and `mapStoredRecordToDocument` returns tags; ensure `createDocument` initializes tags from payload or `[]`; ensure `updateDocument` persists `payload.tags` when provided and preserves existing tags otherwise; ensure `fetchDocuments` includes tags in returned list items. Do not implement sqlite caching or UI changes in this step."
      verification: "Run `cd frontend && npx tsc --noEmit && npm run lint` and confirm no type or lint errors in the modified files."
    - title: add-rust-document-cache-module-and-tauri-commands
      goal: "Implement hidden sqlite cache storage for documents and tags in the documents folder, and expose Tauri invoke commands for reading and writing cache data."
      context: "Rust sqlite pattern already exists in `core/src/config.rs` using rusqlite with an explicit schema and lightweight error enum. `core/Cargo.toml` already includes `rusqlite` and `thiserror`. Tauri command registration pattern is in `frontend/src-tauri/src/lib.rs` with `#[tauri::command]` functions and `tauri::generate_handler!`. Supabase schema reference is `supabase/migrations/002_documents.sql`: `documents` table fields `id`, `user_id`, `title`, `body`, `banner_image_url`, `deleted_at`, `created_at`, `updated_at`; and `document_tags` fields `id`, `document_id`, `tag`, `created_at` with unique `(document_id, tag)`. Cache DB must be in `<documents_folder>/.document-data.db`. This step must provide commands callable from frontend TypeScript."
      instructions: "Create `core/src/document_cache.rs` and export it from `core/src/lib.rs` with `pub mod document_cache;`. In `core/src/document_cache.rs`, implement a sqlite-backed cache store that opens `<documents_folder>/.document-data.db`, enables foreign keys, creates `documents` and `document_tags` tables matching the Supabase field shapes using sqlite-compatible types (`TEXT` for IDs/timestamps/body), and creates indexes for `documents.updated_at`, `document_tags.document_id`, `document_tags.tag`, and unique `(document_id, tag)`. Define serde-serializable structs for command payload/response containing document fields and `tags: Vec<String>`. Implement methods to: list cached documents joined with tags sorted by `updated_at DESC`; upsert one document and fully replace its tags inside a transaction; delete one document by ID; and replace all cached documents in one transaction (clear then insert) for full reindex writes. Then update `frontend/src-tauri/src/lib.rs` to add Tauri commands `get_cached_documents(documents_folder: String)`, `upsert_cached_document(documents_folder: String, document: CachedDocumentPayload)`, `delete_cached_document(documents_folder: String, document_id: String)`, and `replace_cached_documents(documents_folder: String, documents: Vec<CachedDocumentPayload>)`, each mapping Rust errors to `String`. Register all new commands in `tauri::generate_handler!` without removing existing config commands/plugins. Do not change frontend TypeScript in this step."
      verification: "Run `cargo check -p tentacle-core && cargo check -p app` from the repository root and confirm both pass."
    - title: wire-frontend-cache-client-and-document-api-sync
      goal: "Connect frontend document APIs to the new Tauri cache commands so listing can read cached data immediately and CRUD updates keep cache warm."
      context: "Documents folder resolution is already available through `getDocumentsFolderAsync()` in `frontend/lib/settings/documents-folder.ts`. Local document parsing and filesystem reads/writes already exist in `frontend/lib/documents/api.ts` (`listStoredDocumentIds`, `readStoredDocument`, `writeStoredDocument`, and CRUD exports). The Rust commands from the previous step are available via `invoke` from `@tauri-apps/api/core` and have signatures: `get_cached_documents(documents_folder) -> CachedDocumentPayload[]`, `upsert_cached_document(documents_folder, document)`, `delete_cached_document(documents_folder, document_id)`, and `replace_cached_documents(documents_folder, documents)`. `CachedDocumentPayload` must include `id`, `user_id`, `title`, `body`, `banner_image_url`, `deleted_at`, `created_at`, `updated_at`, and `tags`."
      instructions: "Create `frontend/lib/documents/cache.ts` to wrap cache commands with typed helpers: `readCachedDocuments(folder: string): Promise<DocumentListItem[]>`, `upsertCachedDocument(folder: string, document: Document): Promise<void>`, `deleteCachedDocument(folder: string, documentId: string): Promise<void>`, and `replaceCachedDocuments(folder: string, documents: DocumentListItem[]): Promise<void>`. Use `invoke` and normalize missing/invalid payload values safely. Update `frontend/lib/documents/api.ts` to export two explicit list functions: `fetchCachedDocuments(): Promise<DocumentListItem[]>` (reads sqlite cache only, returns `[]` on empty cache or DB-missing conditions) and `reindexDocuments(): Promise<DocumentListItem[]>` (scans markdown files from disk using existing parser logic, returns sorted list, and writes full cache via `replaceCachedDocuments`). Keep existing `fetchDocument`, `createDocument`, `updateDocument`, and `deleteDocument` behavior, but after successful create/update call `upsertCachedDocument` and after delete call `deleteCachedDocument` (cache write failures should be logged and not break document CRUD). Keep the existing `fetchDocuments` export as a compatibility alias to `reindexDocuments` so no existing imports break during transition. Do not modify UI components in this step."
      verification: "Run `cd frontend && npx tsc --noEmit && npm run lint` and confirm `frontend/lib/documents/api.ts` exports `fetchCachedDocuments` and `reindexDocuments` in addition to existing CRUD exports."
    - title: implement-cached-first-document-grid-with-background-reindex
      goal: "Update the documents list UI to render cached content immediately and refresh from filesystem indexing in the background while showing a synchronization indicator."
      context: "`frontend/components/documents/document-grid.tsx` currently calls `fetchDocuments()` once and shows a skeleton until it resolves. After previous steps, `frontend/lib/documents/api.ts` exports `fetchCachedDocuments()` and `reindexDocuments()`, where cached reads are fast and reindex performs full directory scan + cache refresh. `frontend/app/app/page.tsx` renders `<DocumentGrid />` under a Documents heading and already listens for `documents-folder-changed` via `DocumentGrid` logic."
      instructions: "Modify only `frontend/components/documents/document-grid.tsx` in this step. Replace the single-load flow with a two-phase loader: first call `fetchCachedDocuments()` and set `documents` immediately; then kick off `reindexDocuments()` without blocking initial render, update `documents` when reindex completes, and maintain `isSynchronizing` state while it runs. Keep the folder-change event listener, and on folder change repeat the same two-phase process. Add stale-request protection (request counter or cancellation flag) so older async responses cannot overwrite newer state. Show existing skeleton placeholders only during the first cached fetch when nothing is yet available. Render a visible `Synchronizing...` indicator while background reindex is in progress. Do not change routing, card component props, or dashboard page structure."
      verification: "Run `cd frontend && npx tsc --noEmit && npm run lint`. Then run `cd frontend && npm run dev` and verify document cards appear before reindex finishes and a `Synchronizing...` label is visible only during indexing."
    - title: add-tag-input-and-autosave-in-document-detail
      goal: "Provide a thin tag input below the title that stores tags as hashtag tokens and persists through the document autosave flow."
      context: "`frontend/app/app/documents/page.tsx` controls document detail state with `doc`, `title`, `content`, debounced autosave, and `updateDocument` calls. It currently renders the title input directly above `DocumentEditor`. Document type now includes `tags: string[]`, and `updateDocument` accepts `tags?: string[]`. Requirement: tags are typed in a thin input below the title and rendered as `#tag_name`."
      instructions: "Modify `frontend/app/app/documents/page.tsx` to add `tagsInput` state and `lastSavedTags` tracking similar to existing title/body save tracking. On document load, initialize `tagsInput` from `doc.tags` formatted as space-separated hashtags (for example `#meeting #roadmap`) and set `lastSavedTags` from the same canonical array. Add a thin input directly below the title input (small height, subtle border) with placeholder like `#tag_one #tag_two`. Parse input into a normalized string array (strip leading `#`, lowercase, convert spaces to underscores, deduplicate, and ignore empty tokens), debounce it, and auto-save via `updateDocument(doc.id, { tags: parsedTags })` when changed. Keep title/body autosave behavior unchanged. Also update `frontend/components/documents/document-card.tsx` to render up to 3 tags from `document.tags` as small `#tag` chips so tags are visibly reflected in list cards. Do not change editor behavior or add new routes."
      verification: "Run `cd frontend && npx tsc --noEmit && npm run lint`. In the app, type tags in the new input, reload the document, and verify the same tags reappear with hashtag rendering in both detail input and list cards."
    - title: run-end-to-end-validation-for-frontmatter-and-cache
      goal: "Validate that tags persist in markdown frontmatter, sqlite cache is created in the documents folder, and cached-first listing with sync indicator works as expected."
      context: "After previous steps, modified files include `frontend/types/documents.ts`, `frontend/lib/documents/api.ts`, `frontend/lib/documents/cache.ts`, `frontend/components/documents/document-grid.tsx`, `frontend/components/documents/document-card.tsx`, `frontend/app/app/documents/page.tsx`, `core/src/lib.rs`, `core/src/document_cache.rs`, and `frontend/src-tauri/src/lib.rs`. Cache DB path must be `<documents_folder>/.document-data.db`."
      instructions: "Run full quality gates and manual verification. Use `cargo check -p tentacle-core && cargo check -p app`, then `cd frontend && npx tsc --noEmit && npm run lint && npm run build`. Perform manual smoke test in Tauri runtime: choose documents folder, create a document, add tags, return to document list, confirm list appears quickly and shows `Synchronizing...` during background index, then reopen the markdown file and confirm frontmatter contains a `tags` field. Confirm `.document-data.db` exists inside the selected documents folder and includes both documents and tags rows (for example with `sqlite3 '<documents_folder>/.document-data.db' 'SELECT COUNT(*) FROM documents; SELECT COUNT(*) FROM document_tags;'`)."
      verification: "All build/type/lint checks pass and manual smoke test confirms frontmatter tags, hidden sqlite cache creation, cached-first rendering, and synchronization indicator behavior."
  acceptance_criteria[9]:
    - title: tags-exist-in-types-and-api-contracts
      requirement: "`frontend/types/documents.ts` defines `tags: string[]` on `Document` and `DocumentListItem`, and `UpdateDocumentPayload` includes `tags?: string[]`; verify by code inspection and `cd frontend && npx tsc --noEmit`."
    - title: markdown-frontmatter-persists-tags
      requirement: "Saving tags in the document detail UI writes a `tags` field in the markdown frontmatter of the corresponding `.md` file; verify by opening the file in the selected documents folder."
    - title: old-documents-without-tags-remain-readable
      requirement: "Loading a markdown document that has no `tags` frontmatter still succeeds and yields an empty tags array; verify by removing the tags line from a file and reloading the document view."
    - title: sqlite-cache-file-created-in-documents-folder
      requirement: "After document listing/indexing runs, a hidden sqlite file exists at `<documents_folder>/.document-data.db`; verify using `ls -la <documents_folder> | rg '.document-data.db'`."
    - title: cache-schema-stores-documents-and-tags
      requirement: "The sqlite DB contains `documents` and `document_tags` tables with rows for indexed documents and tags; verify using `sqlite3 '<documents_folder>/.document-data.db' '.tables'` and count queries for both tables."
    - title: list-loads-from-cache-before-reindex
      requirement: "`frontend/components/documents/document-grid.tsx` calls `fetchCachedDocuments()` before `reindexDocuments()`, and users see list content without waiting for full filesystem scan; verify by code inspection and runtime behavior."
    - title: synchronizing-indicator-shown-during-index
      requirement: "A visible `Synchronizing...` indicator appears while reindex is running and disappears when complete; verify in the document list UI during app runtime."
    - title: document-crud-keeps-cache-updated
      requirement: "Create/update/delete operations invoke cache synchronization helpers (`upsertCachedDocument`/`deleteCachedDocument`) so cache remains warm between list refreshes; verify by code inspection in `frontend/lib/documents/api.ts`."
    - title: quality-gates-pass
      requirement: "`cargo check -p tentacle-core && cargo check -p app && cd frontend && npx tsc --noEmit && npm run lint && npm run build` completes successfully."
