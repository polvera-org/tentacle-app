plan:
  title: ten-9-local-sqlite-config
  goal: Replace localStorage settings with a shared Rust core config module backed by SQLite so both the Tauri app and future CLI can read/write settings.
  steps[4]:
    - title: create-cargo-workspace-and-core-crate
      goal: Set up the Cargo workspace at the repo root and create the core library crate with a config module backed by rusqlite.
      context: "The repo root is /Users/nicolas/Code/polvera/tentacle-app. There is NO root Cargo.toml yet. The only Rust code lives in frontend/src-tauri/ with its own Cargo.toml (package name 'app', edition 2021). CORE_CLI_PLAN.md describes the planned workspace layout: root Cargo.toml workspace with members ['core', 'cli', 'frontend/src-tauri']. For this step we only create core and add it to the workspace. The core crate will be a library crate. The SQLite database should live in the platform-specific app data directory (on macOS: ~/Library/Application Support/com.tentacle.desktop/). The config table is simple key-value: CREATE TABLE IF NOT EXISTS config (key TEXT PRIMARY KEY, value TEXT NOT NULL). Currently the only setting is 'documents_folder' (a filesystem path string, defaults to ~/Tentacle)."
      instructions: "1. Create /Users/nicolas/Code/polvera/tentacle-app/Cargo.toml as a workspace root with members = ['core', 'frontend/src-tauri']. Do NOT include 'cli' yet since it does not exist. Set resolver = '2'. 2. Create /Users/nicolas/Code/polvera/tentacle-app/core/Cargo.toml with package name 'tentacle-core', version 0.1.0, edition 2021. Add dependencies: rusqlite = { version = '0.35', features = ['bundled'] }, dirs = '6', serde = { version = '1.0', features = ['derive'] }, serde_json = '1.0', thiserror = '2'. 3. Create /Users/nicolas/Code/polvera/tentacle-app/core/src/lib.rs that re-exports the config module: pub mod config;. 4. Create /Users/nicolas/Code/polvera/tentacle-app/core/src/config.rs implementing: (a) A ConfigStore struct that holds a rusqlite::Connection. (b) ConfigStore::new(app_data_dir: &std::path::Path) -> Result<Self, ConfigError> that creates the directory if needed, opens/creates config.db inside it, runs CREATE TABLE IF NOT EXISTS config (key TEXT PRIMARY KEY, value TEXT NOT NULL), and returns the store. (c) pub fn get(&self, key: &str) -> Result<Option<String>, ConfigError>. (d) pub fn set(&self, key: &str, value: &str) -> Result<(), ConfigError>. (e) pub fn delete(&self, key: &str) -> Result<(), ConfigError>. (f) pub fn get_all(&self) -> Result<std::collections::HashMap<String, String>, ConfigError>. (g) A ConfigError enum using thiserror with variants: Sqlite(#[from] rusqlite::Error), Io(#[from] std::io::Error). (h) Convenience constants: pub const KEY_DOCUMENTS_FOLDER: &str = 'documents_folder'. (i) A helper pub fn default_data_dir() -> Option<std::path::PathBuf> that uses dirs::data_dir() and appends 'com.tentacle.desktop'. Keep it simple, no async, no connection pooling."
      verification: "Run 'cargo check -p tentacle-core' from the repo root. It must compile without errors."
    - title: wire-core-config-into-tauri-commands
      goal: Add Tauri commands that expose the core config store to the frontend via invoke.
      context: "frontend/src-tauri/Cargo.toml currently has package name 'app', depends on tauri 2.10.0, serde, serde_json, log, and four tauri plugins (dialog, fs, shell, log). frontend/src-tauri/src/lib.rs registers plugins and calls tauri::Builder::default(). The core crate from step 1 is at path '../core' relative to frontend/src-tauri/ and exports tentacle_core::config::ConfigStore, tentacle_core::config::ConfigError, tentacle_core::config::KEY_DOCUMENTS_FOLDER, tentacle_core::config::default_data_dir. ConfigStore::new(app_data_dir: &Path) -> Result<ConfigStore, ConfigError>, ConfigStore.get(key: &str) -> Result<Option<String>, ConfigError>, ConfigStore.set(key: &str, value: &str) -> Result<(), ConfigError>, ConfigStore.delete(key: &str) -> Result<(), ConfigError>, ConfigStore.get_all() -> Result<HashMap<String, String>, ConfigError>. Tauri 2 manages state via app.manage() and retrieves it in commands via tauri::State<T>. For thread safety, wrap ConfigStore in a Mutex: tauri::State<'_, std::sync::Mutex<ConfigStore>>."
      instructions: "1. Edit frontend/src-tauri/Cargo.toml to add dependency: tentacle-core = { path = '../../core' }. 2. Edit frontend/src-tauri/src/lib.rs to: (a) Add 'use std::sync::Mutex;' and 'use tentacle_core::config::ConfigStore;'. (b) Define three Tauri commands: #[tauri::command] fn get_config(key: String, store: tauri::State<'_, Mutex<ConfigStore>>) -> Result<Option<String>, String> that locks the mutex, calls store.get(&key), and maps errors to String. #[tauri::command] fn set_config(key: String, value: String, store: tauri::State<'_, Mutex<ConfigStore>>) -> Result<(), String> that locks and calls store.set(&key, &value). #[tauri::command] fn get_all_config(store: tauri::State<'_, Mutex<ConfigStore>>) -> Result<std::collections::HashMap<String, String>, String> that locks and calls store.get_all(). (c) In the run() function, before building: resolve the app data dir using tauri::api is not available in v2, so instead use the .setup() closure where you have access to the app handle. Inside setup, get the app data dir via app.path().app_data_dir().unwrap_or_else(|_| tentacle_core::config::default_data_dir().expect('no data dir')), create ConfigStore::new(&data_dir).expect('failed to init config'), and call app.manage(Mutex::new(store)). (d) Register the commands with .invoke_handler(tauri::generate_handler![get_config, set_config, get_all_config]) on the builder. Keep all existing plugin registrations intact."
      verification: "Run 'cargo check -p app' from the repo root. It must compile without errors."
    - title: replace-frontend-localstorage-with-tauri-invoke
      goal: Replace all localStorage reads/writes for settings with Tauri invoke calls to the new config commands.
      context: "frontend/lib/settings/documents-folder.ts (122 lines) currently exports: DOCUMENTS_FOLDER_STORAGE_KEY = 'tentacle.documents-folder', getDocumentsFolder(): string | null (sync, reads localStorage), getDocumentsFolderAsync(): Promise<string> (async, reads localStorage then falls back to default ~/Tentacle), setDocumentsFolder(path: string): void (sync, writes localStorage), pickDocumentsFolder(): Promise<string | null> (async, opens Tauri dialog). Consumers: (1) frontend/lib/documents/api.ts line 1 imports getDocumentsFolder and getDocumentsFolderAsync, uses getDocumentsFolder() on line 114 (sync call in a function called getDocumentsBasePath) and getDocumentsFolderAsync() on line 120 (async fallback). (2) frontend/components/settings/settings-modal.tsx line 4 imports all four exports. The Tauri commands from step 2 are: invoke('get_config', { key }) -> string | null, invoke('set_config', { key, value }) -> void, invoke('get_all_config') -> Record<string,string>. The key constant from core is 'documents_folder'. To call Tauri commands from the frontend use: import { invoke } from '@tauri-apps/api/core'."
      instructions: "1. Rewrite frontend/lib/settings/documents-folder.ts: (a) Remove all localStorage usage. (b) Remove the sync getDocumentsFolder() function entirely -- it cannot work with async Tauri invoke. (c) Export async function getDocumentsFolderAsync(): Promise<string> that calls invoke<string | null>('get_config', { key: 'documents_folder' }), returns the value if non-null, otherwise calls getDefaultDocumentsFolder() (keep existing implementation using Tauri path/fs APIs), saves the default via invoke('set_config', { key: 'documents_folder', value: defaultPath }), and returns it. (d) Export async function setDocumentsFolder(path: string): Promise<void> that calls invoke('set_config', { key: 'documents_folder', value: path }). (e) Keep pickDocumentsFolder() unchanged. (f) Export the constant CONFIG_KEY_DOCUMENTS_FOLDER = 'documents_folder'. Remove the old DOCUMENTS_FOLDER_STORAGE_KEY. 2. Update frontend/components/settings/settings-modal.tsx: Replace the call to sync getDocumentsFolder() on line 24 with await getDocumentsFolderAsync() (already inside an async function). Replace the sync setDocumentsFolder(selectedFolder) on line 61 with await setDocumentsFolder(selectedFolder). Remove the import of getDocumentsFolder (no longer exported). 3. Update frontend/lib/documents/api.ts: Replace import of getDocumentsFolder with only getDocumentsFolderAsync. Find the getDocumentsBasePath function (around line 110-125) that currently tries sync getDocumentsFolder() first then falls back to async getDocumentsFolderAsync() -- simplify it to just call await getDocumentsFolderAsync(). Make getDocumentsBasePath async if not already. Ensure all callers of getDocumentsBasePath await it (they likely already do since the function had an async fallback path)."
      verification: "Run 'cd frontend && npx tsc --noEmit' to verify no TypeScript errors. Run 'grep -r localStorage frontend/lib/settings/' to confirm no localStorage usage remains in the settings module."
    - title: verify-full-build-and-cleanup
      goal: Ensure the entire project builds cleanly end-to-end.
      context: "The project uses a Cargo workspace at the repo root with members ['core', 'frontend/src-tauri']. The frontend is a Next.js 16 static export. Build commands: 'cargo build' from repo root for Rust, 'cd frontend && npm run build' for Next.js. The Tauri dev command is 'cd frontend && npm run tauri dev'. Lint is 'cd frontend && npm run lint'."
      instructions: "1. Run 'cargo build' from the repo root and fix any Rust compilation errors. 2. Run 'cd frontend && npx tsc --noEmit' and fix any TypeScript errors. 3. Run 'cd frontend && npm run lint' and fix any lint errors. 4. Run 'cd frontend && npm run build' and fix any build errors. 5. If all pass, verify the database file would be created correctly by checking that the config module's default_data_dir() returns a sensible path. Do NOT start the Tauri app or run integration tests -- just verify compilation and static analysis pass."
      verification: "Run 'cargo build && cd frontend && npm run lint && npx tsc --noEmit && npm run build' -- all must succeed with zero errors."
  acceptance_criteria[5]:
    - title: core-crate-compiles
      requirement: "Running 'cargo check -p tentacle-core' from the repo root succeeds with no errors."
    - title: tauri-app-compiles-with-core-dependency
      requirement: "Running 'cargo check -p app' from the repo root succeeds with no errors."
    - title: no-localstorage-in-settings
      requirement: "Running 'grep -r localStorage frontend/lib/settings/' returns no matches."
    - title: frontend-type-checks
      requirement: "Running 'cd frontend && npx tsc --noEmit' succeeds with no errors."
    - title: full-build-passes
      requirement: "Running 'cargo build && cd frontend && npm run lint && npm run build' succeeds with zero errors."
